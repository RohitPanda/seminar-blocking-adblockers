from __future__ import division
import glob
import utils
import argparse
import numpy
import progressbar


def parse_commandline():
    parser = argparse.ArgumentParser(description='Print adjacency matrix (combined)')
    parser.add_argument('--input_folder', dest='input', help='Folder containing npy matrices', required='True')
    parser.add_argument('--filemap', dest='filemap', help='File that maps rows/cols to their JS files', required='True')
    parser.add_argument('--statsfile', dest='stats', help='File that contains the stats for each JS file', required='True')
    parser.add_argument('--output', dest='output', help='File containing stats generated by this program', required='True')
    args = parser.parse_args()
    return args


def print_matrix(matrix):
    string = ""
    for row in range(0, matrix.shape[0]):
        string += "\n"
        for col in range(0, matrix.shape[1]):
            string += ("[%d|%d] %f \t" % (row, col, matrix[row][col]))
    print string


def map_stats(stats, fmap):
    s = utils.file_to_dict(stats)
    f = utils.file_to_dict(fmap)
    d = dict()
    for s_entry in s:
        for f_key in f.keys():
            if str(s_entry["site"]) == str(f[f_key]["site"]) and str(s_entry["script-id"]) == str(f[f_key]["script-id"]):
                d[int(f_key)] = {"wcount": int(s_entry["wcount"]), "ccount": int(s_entry["len"])}
                break
    return d


def main():
    files = glob.glob(args.input + "/*.npy")
    d = map_stats(args.stats, args.filemap)
    sim_scores = list()
    ss_wratio, ss_cratio = list(), list()
    wratio, cratio = list(), list()
    matrices = list()
    bar = progressbar.ProgressBar(maxval=len(files), widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])
    bar.start()
    count = 0
    for f in files:
        count += 1
        matrices.append(numpy.load(f))
        bar.update(count)
    matrix = numpy.ones(matrices[0].shape) * -1
    bar = progressbar.ProgressBar(maxval=len(files) * matrix.shape[0] * matrix.shape[1] , widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])
    bar.start()
    count = 0
    for m in matrices:
        for i in range(0, matrix.shape[0]):
            for j in range(0, matrix.shape[1]):
                count += 1
                matrix[i][j] = max(matrix[i][j], m[i][j])
                bar.update(count)
    for i in range(0, matrix.shape[0]):
        for j in range(0, matrix.shape[1]):
            try:
                sim_scores.append(matrix[i][j])
                ss_wratio.append([matrix[i][j], min(d[i]["wcount"], d[j]["wcount"])/max(d[i]["wcount"], d[j]["wcount"])])
                ss_cratio.append([matrix[i][j], min(d[i]["ccount"], d[j]["ccount"])/max(d[i]["ccount"], d[j]["ccount"])])
                wratio.append(min(d[i]["wcount"], d[j]["wcount"])/max(d[i]["wcount"], d[j]["wcount"]))
                cratio.append(min(d[i]["ccount"], d[j]["ccount"])/max(d[i]["ccount"], d[j]["ccount"]))
                bar.update(count)
            except Exception as ex:
                continue
    # print "Sim: ", sim_scores
    # print "WRatio: ", ss_wratio
    # print "CRatio: ", ss_cratio
    o1 = open(args.output + "-wratio-dist", "w")
    wratio.sort()
    for i in range(0, len(wratio)):
        o1.write(str(i/len(wratio)) + "\t" + str(wratio[i]) + "\n")
    o1.close()
    o1 = open(args.output + "-cratio-dist", "w")
    cratio.sort()
    for i in range(0, len(cratio)):
        o1.write(str(i/len(cratio)) + "\t" + str(cratio[i]) + "\n")
    o1.close()
    o1 = open(args.output + "-sim-dist", "w")
    sim_scores.sort()
    for i in range(0, len(sim_scores)):
        o1.write(str(i/len(sim_scores)) + "\t" + str(sim_scores[i]) + "\n")
    o1.close()
    o1 = open(args.output + "-wratio-sim", "w")
    for i in ss_wratio:
        o1.write(str(i[0]) + "\t" + str(i[1]) + "\n")
    o1.close()
    o1 = open(args.output + "-cratio-sim", "w")
    for i in ss_cratio:
        o1.write(str(i[0]) + "\t" + str(i[1]) + "\n")
    o1.close()

    numpy.set_printoptions(threshold=numpy.nan)
    

if __name__ == '__main__':
    args = parse_commandline()
    main()
